{"version":3,"sources":["state/gallerySlice.ts","expressions/scanner.ts","math/random.ts","expressions/symbols.ts","expressions/expression.ts","expressions/glslEmitter.ts","expressions/recognizer.ts","expressions/parser.ts","gl/glUtils.ts","view/Art.tsx","expressions/glsl/header.frag","expressions/glsl/default.vert","expressions/glsl/default.frag","expressions/generator.ts","expressions/evolve.ts","view/Gallery.tsx","view/App.tsx","state/store.ts","index.tsx"],"names":["createArtState","textSource","selected","TokenType","gallerySlice","createSlice","name","initialState","art","settings","highDpiSupport","reducers","addArt","state","event","push","payload","newSource","editArt","index","setAllArt","newArt","deleteArt","splice","toggleSelected","updateSettings","newSettings","actions","selectArt","gallery","selectSettings","isWhitespace","s","test","isOpenParen","c","isCloseParen","Scanner","input","this","length","charAt","Error","nextChar","undefined","tokBuf","skipWhitespace","type","PAREN_OPEN","val","PAREN_CLOSE","terminated","prevChar","SYMBOL","randomInt","min","max","Math","floor","random","randomRange","randomIntLessThan","SymbolType","Expression","args","size","map","arg","reduce","a","b","flatten","expr","join","mapFn","prefixIndex","nextRootIndex","offset","offsetConst","argPath","findPath","offsetSubpath","relative","prefixIndex1","prefixIndex2","path1","path2","j","i","List","of","concat","flatMap","get","exp","newArgs","set","exp1Index","exp2Index","nearestCommonAncestor","glslLiteral","literal","_exp","glslFn","fnName","emit","glslInfix","joiner","getSymbol","glslEmitter","SYMBOLS","CONST","numArgs","tokenRegExp","VAR_X","tokenLiteral","VAR_Y","VAR_T","OP_INV","OP_ABS","OP_SQRT","OP_EXP","OP_LN","OP_SIN","OP_COS","OP_TAN","OP_FLOOR","OP_CEIL","OP_ROUND","OP_TRUNC","OP_CLIP","OP_WRAP","OP_USHIFT","OP_BW","OP_ADD","OP_SUB","OP_MUL","OP_DIV","OP_MOD","OP_DOT","OP_CROSS","OP_POW","OP_LOG","OP_MIN","OP_MAX","OP_NOISE2D","OP_BLEND","OP_RGB","toMap","mapKeys","key","LITERAL_SYMBOLS","filter","_key","k","v","REGEXP_SYMBOLS","entrySeq","symbol","toList","parse","parser","Parser","parseExpression","expectEnd","scanner","nextToken","tokenType","tok","firstToken","expectAndConsume","sym","str","term","recognizeSymbol","createShader","gl","source","shader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","console","error","FRAGMENT_SHADER","VERTEX_SHADER","getShaderInfoLog","deleteShader","Art","props","frameRef","createRef","useState","glProgram","setGlProgram","useSelector","dispatch","useDispatch","getGlContext","getTime","useEffect","log","expression","fragSrc","fragmentShaderSrc","vertexShaderSrc","program","createProgram","vertexShader","fragmentShader","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","deleteProgram","glCanvas","canvas","animationRequest","requestAnimationFrame","render","current","rect","getBoundingClientRect","bottom","top","clientHeight","right","left","clientWidth","width","height","pixelRatio","window","devicePixelRatio","viewport","scissor","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","useProgram","glUniformTime","getUniformLocation","uniform1f","positionLoc","getAttribLocation","vertexAttribPointer","FLOAT","enableVertexAttribArray","drawArrays","TRIANGLE_STRIP","cancelAnimationFrame","className","ref","onClick","SYMBOL_WEIGHTS","weight","cumulative","weights","cumulativeWeights","CUMULATIVE_SYMBOL_WEIGHTS","CUMULATIVE_SYMBOL_WEIGHTS_BY_DEGREE","result","maxArity","tw","inaryWeights","cumulativeByDegree","chooseWeighted","total","r","randomConst","abs","toString","randomExpression","maxDepth","randomSymbolType","randomSymbol","cross","exp1","exp2","sub1","randomSubExpressionAncestorBiased","sub2","mutate","newExp","replacement","replacementMeta","substitute","mapArgs","Gallery","time","useRef","frames","startTime","performance","now","positionBuffer","createBuffer","vertices","Float32Array","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","highDpi","displayWidth","displayHeight","needResize","resizeCanvasToDisplaySize","enable","CULL_FACE","DEPTH_TEST","SCISSOR_TEST","style","transform","scrollY","scrollX","display","generateRandomArt","selectedPieces","piece","parents","n","children","p1","p2","breed","flexWrap","frame","App","id","getContext","antialias","color","href","onChange","e","target","checked","htmlFor","configureStore","reducer","galleryReducer","ReactDOM","store","document","getElementById"],"mappings":"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","file":"static/js/main.fd29ec05.chunk.js","sourcesContent":["import {createSlice, PayloadAction} from '@reduxjs/toolkit'\n\nexport interface GalleryState {\n    art: ArtState[];\n    settings: SettingsState;\n}\n\nexport interface SettingsState {\n    highDpiSupport: boolean;\n}\n\nconst defaultSettings: SettingsState = {\n    highDpiSupport: true,\n};\n\nexport interface ArtState {\n    textSource: string;\n    selected: boolean;\n}\n\nexport function createArtState(textSource: string): ArtState {\n    return {\n        textSource,\n        selected: false,\n    }\n}\n\nexport interface AddArtActionPayload {\n    newSource: string;\n}\n\nexport interface EditArtActionPayload {\n    index: number;\n    newSource: string;\n}\n\nexport interface SetAllArtActionPayload {\n    newArt: ArtState[];\n}\n\nexport interface DeleteArtActionPayload {\n    index: number;\n}\n\nexport interface SelectArtActionPayload {\n    index: number;\n}\n\nexport interface UpdateSettingsActionPayload {\n    newSettings: SettingsState;\n}\n\nexport const gallerySlice = createSlice({\n    name: 'gallery',\n    initialState: {art: [] as ArtState[], settings: defaultSettings} as GalleryState,\n    reducers: {\n        addArt: (state, event: PayloadAction<AddArtActionPayload>) => {\n            state.art.push(createArtState(event.payload.newSource));\n        },\n        editArt: (state, event: PayloadAction<EditArtActionPayload>) => {\n            state.art[event.payload.index].textSource = event.payload.newSource;\n        },\n        setAllArt: (state, event: PayloadAction<SetAllArtActionPayload>) => {\n            state.art = event.payload.newArt;\n        },\n        deleteArt: (state, event: PayloadAction<DeleteArtActionPayload>) => {\n            state.art.splice(event.payload.index, 1);\n        },\n        toggleSelected: (state, event: PayloadAction<SelectArtActionPayload>) => {\n            state.art[event.payload.index].selected = !state.art[event.payload.index].selected;\n        },\n        updateSettings: (state, event: PayloadAction<UpdateSettingsActionPayload>) => {\n          state.settings = event.payload.newSettings;\n        },\n    }\n})\n\nexport const {addArt, editArt, setAllArt, deleteArt, toggleSelected, updateSettings} = gallerySlice.actions\nexport const selectArt = (state: { gallery: GalleryState }) => state.gallery.art;\nexport const selectSettings = (state: { gallery: GalleryState }) => state.gallery.settings;\n\nexport default gallerySlice.reducer","export enum TokenType {\n    PAREN_OPEN = \"PAREN_OPEN\",\n    PAREN_CLOSE = \"PAREN_CLOSE\",\n    SYMBOL = \"SYMBOL\",\n}\n\nexport interface Token {\n    readonly type: TokenType;\n    readonly val: string;\n}\nexport function symbolToken(val: string): Token {\n    return {type: TokenType.SYMBOL, val};\n}\n\nexport function parenOpenToken(): Token {\n    return {type: TokenType.PAREN_OPEN, val: \"(\"};\n}\n\nexport function parenCloseToken(): Token {\n    return {type: TokenType.PAREN_CLOSE, val: \")\"};\n}\n\nfunction isWhitespace(s: string): boolean {\n    return /^\\s+$/.test(s);\n}\n\nfunction isOpenParen(c: string): boolean {\n    return c === \"(\";\n}\n\nfunction isCloseParen(c: string): boolean {\n    return c === \")\";\n}\n\nfunction isParen(c: string): boolean {\n    return isOpenParen(c) || isCloseParen(c);\n}\n\nexport class Scanner {\n    readonly input: string;\n\n    private index: number;\n\n    constructor(input: string) {\n        this.input = input;\n        this.index = 0;\n    }\n\n    /**\n     * Move the scanner forward by one character. Returns the new character or undefined if no more characters.\n     */\n    private nextChar(): string | undefined {\n        if (this.index >= this.input.length) {\n            return undefined;\n        }\n        return this.input.charAt(this.index++);\n    }\n\n    /**\n     * Move the scanner backward by one character.\n     */\n    private prevChar(): void {\n        if (this.index <= 0) {\n            throw Error(`Scan error: prevChar() attempted on scanner at index ${this.index}.`)\n        }\n        this.index--;\n    }\n\n    /**\n     * Move the scanner forward until we get to the next non-whitespace char or the end of the string. Returns the new character or undefined if no more characters.\n     */\n    private skipWhitespace(): string | undefined {\n        let c: string | undefined;\n        do {\n            c = this.nextChar();\n        } while (c !== undefined && isWhitespace(c));\n        return c;\n    }\n\n    /**\n     * Move the scanner forward by one token. Return the new token or undefined if no more tokens.\n     */\n    nextToken(): Token | undefined {\n        let tokBuf = this.skipWhitespace();\n        if (tokBuf === undefined) {\n            return undefined;\n        }\n        if (isOpenParen(tokBuf)) {\n            return parenOpenToken();\n        } else if (isCloseParen(tokBuf)) {\n            return parenCloseToken();\n        }\n        let terminated = false;\n        while (!terminated) {\n            const nextChar = this.nextChar();\n            if (nextChar === undefined || isWhitespace(nextChar)) {\n                terminated = true;\n                break;\n            } else if (isParen(nextChar)) {\n                // Rewind by one char because we need to tokenize the delimiter in the case of parentheses.\n                this.prevChar();\n                terminated = true;\n                break;\n            } else {\n                tokBuf += nextChar;\n            }\n        }\n        return symbolToken(tokBuf);\n    }\n}\n","export function randomRange(min: number, max: number): number {\n    if (max < min) {\n        throw new Error(`Invalid range [${min}, ${max})`);\n    }\n    return min + Math.random() * (max - min);\n}\n\nexport function randomInt(min: number, max: number): number {\n    return Math.floor(randomRange(Math.floor(min), Math.floor(max)));\n}\n\nexport function randomIntLessThan(max: number): number {\n    return randomInt(0, max);\n}","import {List, Map} from \"immutable\";\nimport {glslFn, glslInfix, glslLiteral} from \"./glslEmitter\";\nimport Expression from \"./expression\";\n\nexport enum SymbolType {\n    // Terminals\n    CONST = \"CONST\",\n    VAR_X = \"VAR_X\",\n    VAR_Y = \"VAR_Y\",\n    VAR_T = \"VAR_T\",\n\n    // Unary operators\n    OP_INV = \"OP_INV\",\n    OP_ABS = \"OP_ABS\",\n    OP_SQRT = \"OP_SQRT\",\n    OP_EXP = \"OP_EXP\",\n    OP_LN = \"OP_LN\",\n    OP_SIN = \"OP_SIN\",\n    OP_COS = \"OP_COS\",\n    OP_TAN = \"OP_TAN\",\n    OP_FLOOR = \"OP_FLOOR\",\n    OP_CEIL = \"OP_CEIL\",\n    OP_ROUND = \"OP_ROUND\",\n    OP_TRUNC = \"OP_TRUNC\",\n    OP_CLIP = \"OP_CLIP\",\n    OP_WRAP = \"OP_WRAP\",\n    OP_USHIFT = \"OP_USHIFT\",\n    OP_BW = \"OP_BW\",\n\n    // Binary operators\n    OP_ADD = \"OP_ADD\",\n    OP_SUB = \"OP_SUB\",\n    OP_MUL = \"OP_MUL\",\n    OP_DIV = \"OP_DIV\",\n    OP_MOD = \"OP_MOD\",\n    OP_DOT = \"OP_DOT\",\n    OP_CROSS = \"OP_CROSS\",\n    OP_POW = \"OP_POW\",\n    OP_LOG = \"OP_LOG\",\n    OP_MIN = \"OP_MIN\",\n    OP_MAX = \"OP_MAX\",\n    OP_NOISE2D = \"OP_NOISE2D\",\n\n    // Ternary operators\n    OP_BLEND = \"OP_BLEND\",\n    OP_RGB = \"OP_RGB\",\n}\n\nexport interface Symbol {\n    readonly type: SymbolType;\n    readonly numArgs: number;\n    readonly tokenLiteral?: string;\n    readonly tokenRegExp?: RegExp;\n    readonly glslEmitter: (exp: Expression) => string;\n}\n\nconst SYMBOLS_LIST: List<Symbol> = List.of<Symbol>(\n    // Terminals\n    {\n        type: SymbolType.CONST,\n        numArgs: 0,\n        tokenRegExp: /^-?\\d+(\\.\\d+)?$/,\n        glslEmitter: (exp) => `vec3(${exp.name}, ${exp.name}, ${exp.name})`\n    },\n    {type: SymbolType.VAR_X, numArgs: 0, tokenLiteral: \"x\", glslEmitter: glslLiteral(\"x\")},\n    {type: SymbolType.VAR_Y, numArgs: 0, tokenLiteral: \"y\", glslEmitter: glslLiteral(\"y\")},\n    {type: SymbolType.VAR_T, numArgs: 0, tokenLiteral: \"t\", glslEmitter: glslLiteral(\"t\")},\n\n    // Unary operators\n    {type: SymbolType.OP_INV, numArgs: 1, tokenLiteral: \"inv\", glslEmitter: glslFn(\"inv\")},\n    {type: SymbolType.OP_ABS, numArgs: 1, tokenLiteral: \"abs\", glslEmitter: glslFn(\"abs\")},\n    {type: SymbolType.OP_SQRT, numArgs: 1, tokenLiteral: \"sqrt\", glslEmitter: glslFn(\"sqrt\")},\n    {type: SymbolType.OP_EXP, numArgs: 1, tokenLiteral: \"exp\", glslEmitter: glslFn(\"exp\")},\n    {type: SymbolType.OP_LN, numArgs: 1, tokenLiteral: \"ln\", glslEmitter: glslFn(\"log\")},\n    {type: SymbolType.OP_SIN, numArgs: 1, tokenLiteral: \"sin\", glslEmitter: glslFn(\"sin\")},\n    {type: SymbolType.OP_COS, numArgs: 1, tokenLiteral: \"cos\", glslEmitter: glslFn(\"cos\")},\n    {type: SymbolType.OP_TAN, numArgs: 1, tokenLiteral: \"tan\", glslEmitter: glslFn(\"tan\")},\n    {type: SymbolType.OP_FLOOR, numArgs: 1, tokenLiteral: \"floor\", glslEmitter: glslFn(\"floor\")},\n    {type: SymbolType.OP_CEIL, numArgs: 1, tokenLiteral: \"ceil\", glslEmitter: glslFn(\"ceil\")},\n    {type: SymbolType.OP_ROUND, numArgs: 1, tokenLiteral: \"round\", glslEmitter: glslFn(\"round\")},\n    {type: SymbolType.OP_TRUNC, numArgs: 1, tokenLiteral: \"trunc\", glslEmitter: glslFn(\"trunc\")},\n    {type: SymbolType.OP_CLIP, numArgs: 1, tokenLiteral: \"clip\", glslEmitter: glslFn(\"clip\")},\n    {type: SymbolType.OP_WRAP, numArgs: 1, tokenLiteral: \"wrap\", glslEmitter: glslFn(\"wrap\")},\n    {type: SymbolType.OP_USHIFT, numArgs: 1, tokenLiteral: \"ushift\", glslEmitter: glslFn(\"ushift\")},\n    {type: SymbolType.OP_BW, numArgs: 1, tokenLiteral: \"bw\", glslEmitter: glslFn(\"bw\")},\n\n    // Binary operators\n    {type: SymbolType.OP_ADD, numArgs: 2, tokenLiteral: \"+\", glslEmitter: glslInfix(\"+\")},\n    {type: SymbolType.OP_SUB, numArgs: 2, tokenLiteral: \"-\", glslEmitter: glslInfix(\"-\")},\n    {type: SymbolType.OP_MUL, numArgs: 2, tokenLiteral: \"*\", glslEmitter: glslInfix(\"*\")},\n    {type: SymbolType.OP_DIV, numArgs: 2, tokenLiteral: \"/\", glslEmitter: glslInfix(\"/\")},\n    {type: SymbolType.OP_MOD, numArgs: 2, tokenLiteral: \"%\", glslEmitter: glslFn(\"mod\")},\n    {type: SymbolType.OP_DOT, numArgs: 2, tokenLiteral: \"dot\", glslEmitter: glslFn(\"dotp\")},\n    {type: SymbolType.OP_CROSS, numArgs: 2, tokenLiteral: \"cross\", glslEmitter: glslFn(\"cross\")},\n    {type: SymbolType.OP_POW, numArgs: 2, tokenLiteral: \"pow\", glslEmitter: glslFn(\"pow\")},\n    {type: SymbolType.OP_LOG, numArgs: 2, tokenLiteral: \"log\", glslEmitter: glslFn(\"logb\")},\n     {type: SymbolType.OP_MIN, numArgs: 2, tokenLiteral: \"min\", glslEmitter: glslFn(\"min\")},\n    {type: SymbolType.OP_MAX, numArgs: 2, tokenLiteral: \"max\", glslEmitter: glslFn(\"max\")},\n    {type: SymbolType.OP_NOISE2D, numArgs: 2, tokenLiteral: \"noise2d\", glslEmitter: glslFn(\"snoise2d\")},\n\n    // Ternary operators\n    {type: SymbolType.OP_BLEND, numArgs: 3, tokenLiteral: \"blend\", glslEmitter: glslFn(\"blend\")},\n    {type: SymbolType.OP_RGB, numArgs: 3, tokenLiteral: \"rgb\", glslEmitter: glslFn(\"rgb\")},\n\n);\n\nexport const SYMBOLS: Map<SymbolType, Symbol> = SYMBOLS_LIST.toMap()\n    .mapKeys((key: number, val: Symbol) => val.type);\n\nexport function getSymbol(type: SymbolType): Symbol | undefined {\n    return SYMBOLS.get(type);\n}","import {SymbolType} from \"./symbols\";\nimport {List} from \"immutable\";\nimport {randomIntLessThan} from \"../math/random\";\n\n/**\n * AST representation of an expression.\n *\n * There is no guarantee that each node in the tree is a unique instance. That is why it is necessary to refer to nodes\n * by prefix index relative to some ancestor node.\n */\nexport default class Expression {\n    readonly type: SymbolType;\n    readonly name: string;\n    readonly args: List<Expression>;\n    readonly size: number; // total number of nodes in subtree rooted at this expression.\n\n    constructor(type: SymbolType, name: string, args: List<Expression>) {\n        this.type = type;\n        this.name = name;\n        this.args = args;\n        this.size = args.map(arg => arg.size)\n            .reduce((a, b) => a + b, 1);\n    }\n\n    /**\n     * Return a string representation of this expression in prefix notation.\n     */\n    public toString(): string {\n        return this.flatten().map(expr => expr.name).join(\" \");\n    }\n\n    /**\n     * Apply a map function recursively to the arguments of this expression.\n     */\n    public mapArgs(mapFn: (arg: Expression) => Expression): Expression {\n        return new Expression(this.type, this.name, this.args.map((arg) => mapFn(arg)));\n    }\n\n    /**\n     * Find a path from the root to the sub-expression indicated by prefixIndex.\n     *\n     * Returns the path as a list of prefix indices or undefined if no path exists.\n     */\n    public findPath(prefixIndex: number): number[] | undefined {\n        if (prefixIndex < 0 || prefixIndex >= this.size) {\n            return undefined;\n        }\n        if (prefixIndex === 0) {\n            return [0];\n        }\n        let nextRootIndex = prefixIndex - 1;\n        let offset = 1;\n        for (let arg of this.args) {\n            const offsetConst = offset; // Ref in lambda below needs to be const.\n            const argPath = arg.findPath(nextRootIndex);\n            if (argPath !== undefined) {\n                const offsetSubpath = argPath.map(relative => relative + offsetConst);\n                return [0, ...offsetSubpath];\n            }\n            nextRootIndex -= arg.size;\n            offset += arg.size;\n        }\n        return undefined;\n    }\n\n    /**\n     * Find the nearest common ancestor of the two sub-expressions indicated by their prefix indices.\n     *\n     * Returns the prefix index of the nearest common ancestor or undefined if none exists (this happens iff at least one of the sub-expressions is invalid).\n     */\n    public nearestCommonAncestor(prefixIndex1: number, prefixIndex2: number): number | undefined {\n        const path1 = this.findPath(prefixIndex1);\n        const path2 = this.findPath(prefixIndex2);\n        if (path1 === undefined || path2 === undefined) {\n            return undefined;\n        }\n        let j = path2.length - 1;\n        for (let i = path1.length - 1; i >= 0; i--) {\n            while (j > 0 && path2[j] > path1[i]) {\n                j--;\n            }\n            if (path1[i] === path2[j]) {\n                return path1[i];\n            }\n        }\n        return 0;\n    }\n\n    /**\n     * Flatten this expression into a list of expressions in prefix order.\n     */\n    public flatten(): List<Expression> {\n        return List.of<Expression>(this)\n            .concat(this.args.flatMap((expr) => expr.flatten()));\n    }\n\n    /**\n     * Get the sub-expression indicated by the\n     */\n    public get(prefixIndex: number): Expression | undefined {\n        return this.flatten().get(prefixIndex);\n    }\n\n    /**\n     * Replace the sub-expression indicated by prefixIndex by the given expression.\n     */\n    public set(prefixIndex: number, exp: Expression): Expression {\n        if (prefixIndex < 0 || prefixIndex >= this.size) {\n            return this;\n        }\n        if (prefixIndex === 0) {\n            return exp;\n        }\n        let nextRootIndex = prefixIndex - 1;\n        const newArgs: Expression[] = []\n        for (let arg of this.args) {\n            newArgs.push(arg.set(nextRootIndex, exp));\n            nextRootIndex -= arg.size;\n        }\n        return new Expression(this.type, this.name, List.of(...newArgs));\n    }\n\n    /**\n     * Choose a random sub-expression uniformly.\n     */\n    public randomSubExpression(): number {\n        return randomIntLessThan(this.size);\n    }\n\n    /**\n     * Choose a random sub-expression where each is weighted by how many sub-expression pairs it is the nearest common ancestor of.\n     */\n    public randomSubExpressionAncestorBiased(): number {\n        const exp1Index = randomIntLessThan(this.size);\n        const exp2Index = randomIntLessThan(this.size);\n        return this.nearestCommonAncestor(exp1Index, exp2Index)!;\n    }\n}\n\n","// eslint-disable-next-line import/no-webpack-loader-syntax\nimport header from \"!raw-loader!./glsl/header.frag\";\nimport Expression from \"./expression\";\nimport {getSymbol} from \"./symbols\";\n\nexport function glslLiteral(literal: string): (exp: Expression) => string {\n    return (_exp) => literal;\n}\n\nexport function glslFn(fnName: string): (exp: Expression) => string {\n    return (exp: Expression) => `${fnName}(${exp.args.map(arg => emit(arg)).join(\", \")})`;\n}\n\nexport function glslInfix(joiner: string): (exp: Expression) => string {\n    return ((exp: Expression) => `(${exp.args.map(arg => emit(arg)).join(joiner)})`);\n}\n\nfunction emit(exp: Expression): string {\n    return getSymbol(exp.type)!.glslEmitter(exp);\n}\n\nexport function emitGlsl(exp: Expression): string {\n    return header + `\nvec3 expression(vec3 x, vec3 y, vec3 t) {\n    return ${emit(exp)};\n}\n`;\n}","import {List, Map} from \"immutable\";\nimport {Symbol, SYMBOLS, SymbolType} from \"./symbols\";\n\nconst LITERAL_SYMBOLS: Map<string, Symbol> = SYMBOLS\n    .filter((val: Symbol, _key: SymbolType) => (val.tokenLiteral !== undefined))\n    .mapKeys((k: SymbolType, v: Symbol) => v.tokenLiteral!);\n\nconst REGEXP_SYMBOLS: List<Symbol> = SYMBOLS\n    .entrySeq()\n    .map(([_symbolType, symbol]) => symbol)\n    .filter((symbol) => symbol.tokenRegExp !== undefined)\n    .toList();\n\nexport function recognizeSymbol(str: string): Symbol | undefined {\n    const term = LITERAL_SYMBOLS.get(str);\n    if (term !== undefined) {\n        return term;\n    }\n    for (const term of REGEXP_SYMBOLS) {\n        if (term.tokenRegExp!.test(str)) {\n            return term;\n        }\n    }\n}","import {Scanner, TokenType} from \"./scanner\";\nimport Expression from \"./expression\";\nimport {List} from \"immutable\";\nimport {recognizeSymbol} from \"./recognizer\";\n\n/**\n * Parse a string representing an expression into an Expression AST.\n *\n * Grammar:\n * Expression -> (Expression)\n * Expression -> SYMBOL ArgList\n * ArgList -> Expression ArgList\n * ArgList -> _\n *\n * Each SYMBOL token represents either an Operator with a known number of arguments, a variable, or a constant value.\n */\n\nexport function parse(input: string): Expression {\n    const parser: Parser = new Parser(input);\n    const exp = parser.parseExpression();\n    parser.expectEnd();\n    return exp;\n}\n\nclass Parser {\n    readonly scanner: Scanner;\n\n    constructor(input: string) {\n        this.scanner = new Scanner(input);\n    }\n\n    expectEnd(): void {\n        const nextToken = this.scanner.nextToken();\n        if (nextToken !== undefined) {\n            throw Error(`Parse error: Expected end of expression, found \"${nextToken.val}\"`);\n        }\n    }\n\n    expectAndConsume(tokenType: TokenType): void {\n        const tok = this.scanner.nextToken();\n        if (tok === undefined) {\n            throw Error(`Parse error: Expected token of type ${tokenType}, found none.`)\n        } else if (tok.type !== tokenType) {\n            throw Error(`Parse error: Expected token of type ${tokenType}, found token of type ${tok.type}.`)\n        }\n    }\n\n    parseExpression(): Expression {\n        const firstToken = this.scanner.nextToken();\n        if (firstToken === undefined) {\n            throw Error(`Parse error: Expected expression, found none.`);\n        } else if (firstToken.type === TokenType.PAREN_OPEN) { // Expression -> (Expression)\n            const exp = this.parseExpression();\n            this.expectAndConsume(TokenType.PAREN_CLOSE);\n            return exp;\n        } else if (firstToken.type === TokenType.SYMBOL) { // Expression -> SYMBOL ArgList\n            const sym = recognizeSymbol(firstToken.val);\n            if (sym === undefined) {\n                throw new Error(`Parse error: Unrecognized symbol: \"${firstToken.val}\"`);\n            }\n            // ArgList -> Expression ArgList\n            // ArgList -> _\n            const args = [];\n            for (let i = 0; i < sym.numArgs; i++) {\n                args.push(this.parseExpression());\n            }\n            return new Expression(\n                sym.type,\n                firstToken.val,\n                List.of(...args));\n        }\n        throw Error(`Parse error: Unexpected token: ${firstToken}.`);\n    }\n}","// eslint-disable-next-line import/no-webpack-loader-syntax\nimport defaultVert from \"!raw-loader!../expressions/glsl/default.vert\";\n// eslint-disable-next-line import/no-webpack-loader-syntax\nimport defaultFrag from \"!raw-loader!../expressions/glsl/default.frag\";\n\nfunction createShader(\n    gl: WebGLRenderingContext, type: GLenum, source: string): WebGLShader | null {\n    // console.log(source);\n    const shader: WebGLShader = gl.createShader(type)!;\n    gl.shaderSource(shader, source);\n    gl.compileShader(shader);\n    const success: boolean = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n    if (success) {\n        return shader;\n    }\n    console.error(`Failed to compile ${type === gl.FRAGMENT_SHADER ? \"FRAGMENT_SHADER\" : (type\n    === gl.VERTEX_SHADER\n        ? \"VERTEX_SHADER\" : \"UNKNOWN SHADER TYPE\")}:`);\n    console.error(source);\n    console.error(gl.getShaderInfoLog(shader));\n    gl.deleteShader(shader);\n    return null;\n}\n\nexport function createProgram(\n    gl: WebGLRenderingContext, fragmentShaderSrc?: string, vertexShaderSrc?: string): WebGLProgram | null {\n    const program: WebGLProgram = gl.createProgram()!;\n    const vertexShader: WebGLShader | null = createShader(gl, gl.VERTEX_SHADER, vertexShaderSrc ? vertexShaderSrc : defaultVert);\n    const fragmentShader: WebGLShader | null = createShader(\n        gl, gl.FRAGMENT_SHADER, fragmentShaderSrc ? fragmentShaderSrc : defaultFrag);\n\n    if (!vertexShader || !fragmentShader) {\n        gl.deleteProgram(program);\n        return null;\n    }\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    gl.linkProgram(program);\n    const success = gl.getProgramParameter(program, gl.LINK_STATUS);\n    if (success) {\n        return program;\n    }\n    console.error(`Failed to create GL program:`);\n    console.error(gl.getProgramInfoLog(program));\n    gl.deleteProgram(program);\n    return null;\n}","import { parse } from \"../expressions/parser\";\nimport { emitGlsl } from \"../expressions/glslEmitter\";\nimport { createProgram } from \"../gl/glUtils\";\nimport { createRef, useEffect, useState } from \"react\";\nimport { ArtState, selectSettings, toggleSelected } from \"../state/gallerySlice\";\nimport { useDispatch, useSelector } from \"react-redux\";\n\nexport default function Art(props: {\n    art: ArtState,\n    index: number,\n    getTime: () => number,\n    getGlContext: () => WebGLRenderingContext | null,\n}) {\n    const frameRef = createRef<HTMLDivElement>();\n    const [glProgram, setGlProgram] = useState<WebGLProgram | null>(null);\n    const settings = useSelector(selectSettings);\n    const dispatch = useDispatch();\n\n    const gl = props.getGlContext();\n    const source = props.art.textSource;\n    const getTime = props.getTime;\n\n    // Compile gl program.\n    useEffect(() => {\n        if (gl === null) {\n            return;\n        }\n        console.log(\"Recompiling...\");\n        const expression = parse(source)!;\n        const fragSrc = emitGlsl(expression);\n        setGlProgram(createProgram(gl, fragSrc));\n    }, [gl, source]);\n\n    // Start rendering\n    useEffect(() => {\n        if (gl === null) {\n            return;\n        }\n        const glCanvas = gl.canvas as HTMLCanvasElement;\n\n        let animationRequest = 0;\n        const render = () => {\n            if (frameRef.current === null) {\n                return;\n            }\n            const rect = frameRef.current!.getBoundingClientRect();\n            if (!(rect.bottom < 0 || rect.top > glCanvas.clientHeight ||\n                rect.right < 0 || rect.left > glCanvas.clientWidth)) {\n\n                const width = rect.right - rect.left;\n                const height = rect.bottom - rect.top;\n                const left = rect.left;\n                const bottom = glCanvas.clientHeight - rect.bottom;\n                const pixelRatio = settings.highDpiSupport ? window.devicePixelRatio || 1 : 1;\n\n                gl.viewport(left * pixelRatio, bottom * pixelRatio, width * pixelRatio, height * pixelRatio);\n                gl.scissor(left * pixelRatio, bottom * pixelRatio, width * pixelRatio, height * pixelRatio);\n\n                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n                gl.useProgram(glProgram);\n\n                const glUniformTime = gl.getUniformLocation(glProgram!, \"time\");\n                gl.uniform1f(glUniformTime, getTime());\n\n                const positionLoc = gl.getAttribLocation(glProgram!, \"xy_pos\");\n                gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);\n                gl.enableVertexAttribArray(positionLoc);\n\n                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n            }\n            animationRequest = requestAnimationFrame(render);\n        }\n        animationRequest = requestAnimationFrame(render);\n        return () => {\n            cancelAnimationFrame(animationRequest);\n        }\n    }, [settings.highDpiSupport, frameRef, gl, glProgram, getTime]);\n\n    return <div className={\"ArtFrame\" + (props.art.selected ? \" Selected\" : \" Deselected\")}>\n        <div ref={frameRef} className=\"ArtFrameClickTarget\"\n            onClick={() => dispatch(toggleSelected({ index: props.index }))} />\n    </div>\n}","export default \"#define F_PI 3.14159\\n#define F_TAU 6.28318\\n#define F_E 2.71828\\n#define F_PHI 1.61803\\n\\n#define PI vec3(F_PI, F_PI, F_PI)\\n#define TAU vec3(F_TAU, F_TAU, F_TAU)\\n#define E vec3(F_E, F_E, F_E)\\n#define PHI vec3(F_PHI, F_PHI, F_PHI)\\n\\nprecision highp float;\\n\\n// (x, y) coordinates expected to be varying from [-1, 1]\\nvarying vec2 pos;\\n// time expected to be varying from [0, 1]\\nuniform float time;\\n\\nfloat rand(vec2 c){\\n    return fract(sin(dot(c.xy, vec2(12.9898, 78.233))) * 43758.5453);\\n}\\n\\n//\\n// Description : Array and textureless GLSL 2D simplex noise function.\\n//      Author : Ian McEwan, Ashima Arts.\\n//  Maintainer : stegu\\n//     Lastmod : 20110822 (ijm)\\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\\n//               Distributed under the MIT License. See LICENSE file.\\n//               https://github.com/ashima/webgl-noise\\n//               https://github.com/stegu/webgl-noise\\n//\\n\\nvec3 mod289(vec3 x) {\\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec2 mod289(vec2 x) {\\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec3 permute(vec3 x) {\\n    return mod289(((x*34.0)+10.0)*x);\\n}\\n\\nfloat snoise(vec2 v) {\\n    const vec4 C = vec4(0.211324865405187, // (3.0-sqrt(3.0))/6.0\\n    0.366025403784439, // 0.5*(sqrt(3.0)-1.0)\\n    -0.577350269189626, // -1.0 + 2.0 * C.x\\n    0.024390243902439);// 1.0 / 41.0\\n    // First corner\\n    vec2 i  = floor(v + dot(v, C.yy));\\n    vec2 x0 = v -   i + dot(i, C.xx);\\n\\n    // Other corners\\n    vec2 i1;\\n    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\\n    //i1.y = 1.0 - i1.x;\\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\\n    // x1 = x0 - i1 + 1.0 * C.xx ;\\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\\n    vec4 x12 = x0.xyxy + C.xxzz;\\n    x12.xy -= i1;\\n\\n    // Permutations\\n    i = mod289(i);// Avoid truncation effects in permutation\\n    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0))\\n    + i.x + vec3(0.0, i1.x, 1.0));\\n\\n    vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);\\n    m = m*m;\\n    m = m*m;\\n\\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\\n    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\\n\\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\\n    vec3 h = abs(x) - 0.5;\\n    vec3 ox = floor(x + 0.5);\\n    vec3 a0 = x - ox;\\n\\n    // Normalise gradients implicitly by scaling m\\n    // Approximation of: m *= inversesqrt( a0*a0 + h*h );\\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);\\n\\n    // Compute final noise value at P\\n    vec3 g;\\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\\n    return 130.0 * dot(m, g);\\n}\\n\\n// End Simplex noise from https://github.com/stegu/webgl-noise\\n\\nvec3 snoise2d(vec3 a, vec3 b) {\\n    return vec3(snoise(vec2(a.x, b.x)), snoise(vec2(a.y, b.y)), snoise(vec2(a.z, b.z)));\\n}\\n\\nvec3 expression(vec3 x, vec3 y, vec3 t);\\n\\nvec3 inv(vec3 v) {\\n    return -v;\\n}\\n\\nvec3 dotp(vec3 a, vec3 b) {\\n    return vec3(dot(a, b));\\n}\\n\\nvec3 logb(vec3 x, vec3 b) {\\n    return log(x) / log(b);\\n}\\n\\nvec3 round(vec3 v) {\\n    return floor(0.5 + v);\\n}\\n\\nvec3 trunc(vec3 v) {\\n    return vec3(int(v.x), int(v.y), int(v.z));\\n}\\n\\nvec3 clip(vec3 v) {\\n    return max(min(v, 1.0), -1.0);\\n}\\n\\nvec3 wrap(vec3 v) {\\n    return mod(v + 1.0, vec3(3.0)) - 1.0;\\n}\\n\\nvec3 ushift(vec3 v) {\\n    return (v + 1.0) / 2.0;\\n}\\n\\n// fac * a + (1 - fac) * b\\n// TODO: Consider clipping fac to [0, 1]\\nvec3 blend(vec3 a, vec3 b, vec3 fac) {\\n    return (fac * a) + ((vec3(1.0) - fac) * b);\\n}\\n\\nvec3 rgb(vec3 r, vec3 g, vec3 b) {\\n    return vec3(r.x, g.x, b.x);\\n}\\n\\nvec3 bw(vec3 rgb) {\\n    return vec3(0.3 * rgb.x + 0.59 * rgb.y + 0.11 * rgb.z);\\n}\\n\\nvoid main() {\\n    vec3 x = vec3(pos.x);\\n    vec3 y = vec3(pos.y);\\n    vec3 t = vec3(time, time, time);\\n    vec3 rgb = expression(x, y, t);\\n    gl_FragColor = vec4(rgb, 1.0);\\n}\";","export default \"precision highp float;\\n\\nattribute vec2 xy_pos;\\nvarying vec2 pos;\\nvoid main() {\\n    pos = xy_pos;\\n    gl_Position = vec4(xy_pos, 0, 1);\\n}\";","export default \"precision highp float;\\n\\nvoid main() {\\n    gl_FragColor = vec4(1, 0, 1, 1);\\n}\";","import {getSymbol, SymbolType} from \"./symbols\";\nimport {List} from \"immutable\";\nimport Expression from \"./expression\";\n\nexport interface SymbolWeight {\n    readonly type: SymbolType;\n    readonly weight: number;\n}\n\nconst SYMBOL_WEIGHTS: SymbolWeight[] = [\n    {type: SymbolType.CONST, weight: 1},\n    {type: SymbolType.VAR_X, weight: 1},\n    {type: SymbolType.VAR_Y, weight: 1},\n    {type: SymbolType.VAR_T, weight: 2},\n\n    {type: SymbolType.OP_INV, weight: 1},\n    {type: SymbolType.OP_ABS, weight: 1},\n    {type: SymbolType.OP_ADD, weight: 1},\n    {type: SymbolType.OP_SUB, weight: 1},\n    {type: SymbolType.OP_MUL, weight: 1},\n    {type: SymbolType.OP_DIV, weight: 1},\n    {type: SymbolType.OP_MOD, weight: 1},\n    {type: SymbolType.OP_DOT, weight: 1},\n    {type: SymbolType.OP_CROSS, weight: 1},\n    {type: SymbolType.OP_SQRT, weight: 1},\n    {type: SymbolType.OP_POW, weight: 1},\n    {type: SymbolType.OP_EXP, weight: 1},\n    {type: SymbolType.OP_LOG, weight: 1},\n    {type: SymbolType.OP_LN, weight: 1},\n    {type: SymbolType.OP_SIN, weight: 1},\n    {type: SymbolType.OP_COS, weight: 1},\n    {type: SymbolType.OP_TAN, weight: 1},\n    {type: SymbolType.OP_FLOOR, weight: 1},\n    {type: SymbolType.OP_CEIL, weight: 1},\n    {type: SymbolType.OP_ROUND, weight: 1},\n    {type: SymbolType.OP_TRUNC, weight: 1},\n    {type: SymbolType.OP_MIN, weight: 1},\n    {type: SymbolType.OP_MAX, weight: 1},\n    {type: SymbolType.OP_CLIP, weight: 1},\n    {type: SymbolType.OP_WRAP, weight: 1},\n    {type: SymbolType.OP_USHIFT, weight: 1},\n    {type: SymbolType.OP_BLEND, weight: 1},\n    {type: SymbolType.OP_RGB, weight: 2},\n    {type: SymbolType.OP_BW, weight: 1},\n\n    {type: SymbolType.OP_NOISE2D, weight: 2},\n];\n\nfunction cumulative(weights: SymbolWeight[]): SymbolWeight[] {\n    let cumulativeWeights = [weights[0]];\n    for (let i = 1; i < weights.length; i++) {\n        cumulativeWeights.push({type: weights[i].type, weight: cumulativeWeights[i - 1].weight + weights[i].weight});\n    }\n    return cumulativeWeights;\n}\n\nfunction cumulativeByDegree(weights: SymbolWeight[]): SymbolWeight[][] {\n    if (weights.length === 0) {\n        return [[]];\n    }\n    let result = [];\n    const maxArity = Math.max(...weights.map((tw) => getSymbol(tw.type)!.numArgs));\n    for (let i = 0; i <= maxArity; i++) {\n        const inaryWeights = cumulative(SYMBOL_WEIGHTS\n            .filter((tw) => getSymbol(tw.type)?.numArgs === i));\n        result.push(inaryWeights);\n    }\n    return result;\n}\n\nexport const CUMULATIVE_SYMBOL_WEIGHTS = cumulative(SYMBOL_WEIGHTS);\nexport const CUMULATIVE_SYMBOL_WEIGHTS_BY_DEGREE = cumulativeByDegree(SYMBOL_WEIGHTS)\n\nexport function chooseWeighted(cumulativeWeights: SymbolWeight[]): SymbolType | undefined {\n    if (cumulativeWeights.length === 0) {\n        return undefined;\n    }\n    // TODO: Validate that we have a monotonically increasing distribution.\n    const total = cumulativeWeights[cumulativeWeights.length - 1].weight;\n    const r = Math.random() * total;\n    // TODO: Binary search.\n    for (let i = 0; i < cumulativeWeights.length; i++) {\n        if (r <= cumulativeWeights[i].weight) {\n            return cumulativeWeights[i].type\n        }\n    }\n    // Should never get here.\n    throw new Error(\"Whoops, fell through chooseWeighted.\");\n}\n\nexport function randomConst(min: number, max: number): Expression {\n    const val = Math.random() * Math.abs(max - min) + Math.min(min, max);\n    return new Expression(SymbolType.CONST, val.toString(), List.of());\n}\n\nexport function randomExpression(maxDepth: number): Expression {\n    if (maxDepth <= 0) {\n        throw new Error(\"Invalid random expression depth.\");\n    }\n    let randomSymbolType: SymbolType;\n    if (maxDepth === 1) {\n        randomSymbolType = chooseWeighted(CUMULATIVE_SYMBOL_WEIGHTS_BY_DEGREE[0])!;\n    } else {\n        randomSymbolType = chooseWeighted(CUMULATIVE_SYMBOL_WEIGHTS)!;\n    }\n    const randomSymbol = getSymbol(randomSymbolType)!;\n    if (randomSymbol.tokenLiteral === undefined) {\n        return randomConst(-10, 10);\n    }\n    const args: Expression[] = [];\n    for (let i = 0; i < randomSymbol.numArgs; i++) {\n        args.push(randomExpression(maxDepth - 1));\n    }\n    return new Expression(randomSymbolType, randomSymbol.tokenLiteral, List.of(...args));\n}","import Expression from \"./expression\";\nimport {randomIntLessThan} from \"../math/random\";\nimport {getSymbol} from \"./symbols\";\nimport {chooseWeighted, CUMULATIVE_SYMBOL_WEIGHTS_BY_DEGREE, randomConst} from \"./generator\";\n\nexport function breed(parents: Expression[], n = -1): Expression[] {\n    if (n < 0) {\n        n = parents.length;\n    }\n    let children = [];\n    for (let i = 0; i < n; i++) {\n        const p1 = parents[randomIntLessThan(parents.length)];\n        const p2 = parents[randomIntLessThan(parents.length)];\n        children.push(mutate(cross(p1, p2)));\n    }\n    return children;\n}\n\nexport function cross(exp1: Expression, exp2: Expression): Expression {\n    const sub1 = exp1.randomSubExpressionAncestorBiased();\n    const sub2 = exp2.randomSubExpressionAncestorBiased();\n    return exp1.set(sub1, exp2.get(sub2)!);\n}\n\nfunction substitute(exp: Expression): Expression {\n    const replacement = chooseWeighted(CUMULATIVE_SYMBOL_WEIGHTS_BY_DEGREE[exp.args.size]);\n    if (replacement === undefined) {\n        return exp;\n    }\n    const replacementMeta = getSymbol(replacement)!;\n    if (replacementMeta.numArgs !== exp.args.size ) {\n        throw new Error(\"Arity mismatch during substitution mutation.\");\n    }\n    // TODO: Handle this better.\n    if (replacementMeta.tokenLiteral === undefined) {\n        return randomConst(-10, 10);\n    }\n    return new Expression(replacement, replacementMeta.tokenLiteral, exp.args);\n}\n\nexport function mutate(exp: Expression): Expression {\n    const r = Math.random();\n    let newExp = exp;\n    if (r < 0.99) { // none\n    } else if (r < 1.0) { // substitution\n        newExp = substitute(exp);\n    }\n    return newExp.mapArgs(mutate);\n}","import React, {useEffect, useRef} from 'react'\nimport {useDispatch, useSelector} from 'react-redux'\nimport {createArtState, selectArt, selectSettings, setAllArt} from \"../state/gallerySlice\";\nimport \"./Gallery.css\";\nimport {generateRandomArt} from \"./App\";\nimport Art from \"./Art\";\nimport {parse} from \"../expressions/parser\";\nimport {breed} from \"../expressions/evolve\";\n\nfunction resizeCanvasToDisplaySize(canvas: HTMLCanvasElement, highDpi: boolean): boolean {\n    const pixelRatio = highDpi ? window.devicePixelRatio || 1 : 1;\n    // Lookup the size the browser is displaying the canvas in CSS pixels.\n    const displayWidth = canvas.clientWidth * pixelRatio;\n    const displayHeight = canvas.clientHeight * pixelRatio;\n\n    // Check if the canvas is not the same size.\n    const needResize = canvas.width !== displayWidth ||\n        canvas.height !== displayHeight;\n\n    if (needResize) {\n        // Make the canvas the same size\n        canvas.width = displayWidth;\n        canvas.height = displayHeight;\n    }\n    return needResize;\n}\n\nexport default function Gallery(props: { getGlContext: () => WebGLRenderingContext | null }) {\n    const time = useRef<number>(0);\n    const settings = useSelector(selectSettings);\n    const art = useSelector(selectArt);\n    const frames = useSelector(selectArt)\n        .map((art, i) =>\n            <Art art={art}\n                 index={i}\n                 getTime={() => time.current}\n                 getGlContext={props.getGlContext}/>);\n\n    const dispatch = useDispatch();\n    const gl = props.getGlContext();\n    // Set up OpenGL.\n    useEffect(() => {\n        if (gl === null) {\n            return;\n        }\n        let animationRequest = 0;\n        const startTime = performance.now();\n        const glCanvas = gl.canvas as HTMLCanvasElement;\n        const render = () => {\n            time.current = (((performance.now() - startTime) / 1000) / 5) % 1;\n            resizeCanvasToDisplaySize(glCanvas, settings.highDpiSupport);\n            gl.enable(gl.CULL_FACE);\n            gl.enable(gl.DEPTH_TEST);\n            gl.enable(gl.SCISSOR_TEST);\n\n            // move the canvas to top of the current scroll position\n            (gl.canvas as HTMLCanvasElement).style.transform = `translateY(${window.scrollY}px) translateX(${window.scrollX}px)`;\n            animationRequest = requestAnimationFrame(render);\n        }\n        const positionBuffer = gl.createBuffer();\n        const vertices = new Float32Array([\n            -1.0, 1.0,\n            -1.0, -1.0,\n            1.0, 1.0,\n            1.0, -1.0\n        ]);\n        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);\n        animationRequest = requestAnimationFrame(render);\n        return () => {\n            cancelAnimationFrame(animationRequest);\n        }\n    }, [gl, settings.highDpiSupport]);\n\n    return (\n        <div className=\"Gallery\">\n            <div className=\"Instructions\">\n                <div>\n                    Select expressions you like by clicking on them. Press \"Breed selected\" to breed the selected\n                    expressions together randomly.\n                    <br/>\n                    <br/>\n                    If you don't like any of the expressions then press \"Start over\" to get new ones.\n                    <br/>\n                    <br/>\n                </div>\n            </div>\n            <div className=\"Controls\" style={{display: \"flex\"}}>\n                <button onClick={() => {\n                    dispatch(setAllArt({newArt: generateRandomArt()}));\n                }}>Start over\n                </button>\n                <button onClick={() => {\n                    const selectedPieces = art.filter((piece, i) => piece.selected)\n                        .map(piece => parse(piece.textSource)!);\n                    if (selectedPieces.length === 0) {\n                        return;\n                    }\n                    const newArt = breed(selectedPieces, art.length)\n                        .map((expression, i) => createArtState(expression.toString()));\n                    dispatch(setAllArt({newArt}));\n                }}>Breed selected\n                </button>\n            </div>\n            <div className=\"GalleryFlow\" style={{display: \"flex\", flexWrap: \"wrap\"}}>\n                {frames.map((frame, i) =>\n                    <div key={i.toString()}>\n                        {frame}\n                    </div>)}\n            </div>\n        </div>\n    );\n}","import Gallery from \"./Gallery\";\nimport React, {useEffect, useRef} from \"react\";\nimport {useDispatch, useSelector} from \"react-redux\";\nimport {ArtState, createArtState, selectSettings, setAllArt, updateSettings} from \"../state/gallerySlice\";\nimport {randomExpression} from \"../expressions/generator\";\nimport \"./App.css\";\n\nexport function generateRandomArt(n = 21): ArtState[] {\n    const newArt = [];\n    for (let i = 0; i < n; i++) {\n        newArt.push(createArtState(randomExpression(6).toString()));\n    }\n    return newArt;\n}\n\nexport default function App() {\n    const canvas = useRef<HTMLCanvasElement>(null);\n    const settings = useSelector(selectSettings);\n    const dispatch = useDispatch();\n\n    const getGlContext = () => {\n        if (canvas.current === null) {\n            return null;\n        }\n        return canvas.current.getContext('webgl', {antialias: false});\n    }\n\n    // Generate initial functions.\n    useEffect(() => {\n        dispatch(setAllArt({newArt: generateRandomArt()}));\n    }, [dispatch]);\n    return (<div>\n        <canvas ref={canvas} id=\"glCanvas\"/>\n        <Gallery getGlContext={getGlContext}/>\n        <div>\n            <i>\"This art may not make sense to you. It makes Ness sleepy just thinking about it. Use Paralysis to knock\n                some sense into the painting.\"</i>\n            <br/>\n            — EarthBound Player's Guide\n        </div>\n        <br/>\n        <div style={{color: \"yellow\"}}>\n            UX developer wanted :)\n        </div>\n        <div style={{color: \"blue\"}}>\n            <a href=\"https://github.com/mbh95/abstract-art\">GitHub repo</a>\n        </div>\n        <input type=\"checkbox\"\n               name=\"highdpi\"\n               onChange={(e) => dispatch(updateSettings({newSettings: {highDpiSupport: e.target.checked}}))}\n               checked={settings.highDpiSupport}/>\n        <label htmlFor=\"highdpi\">High DPI Support</label>\n    </div>);\n}","import { configureStore } from '@reduxjs/toolkit'\nimport galleryReducer from \"./gallerySlice\"\nexport default configureStore({\n    reducer: {\n        gallery: galleryReducer\n    }\n})","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport \"./index.css\";\nimport App from \"./view/App\";\nimport {Provider} from \"react-redux\";\nimport store from \"./state/store\";\n\n\nReactDOM.render(<Provider store={store}><App/></Provider>, document.getElementById('root'));"],"sourceRoot":""}